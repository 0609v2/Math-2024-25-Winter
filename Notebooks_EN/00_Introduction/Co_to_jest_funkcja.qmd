---
title: Definicja funkcji
jupyter: python3
---


**Teoriomnogościowa definicja funkcji** mówi, że funkcja $f$ jest specjalnym przypadkiem relacji. Relacja to po prostu dowolny zbiór par uporządkowanych. Funkcja natomiast jest taką relacją $f \subseteq X \times Y$, która spełnia dodatkowe założenie: każdemu elementowi $x \in X$ przyporządkowany jest **dokładnie jeden** element $y \in Y$.

Formalnie, funkcja $f$ to relacja, która spełnia następujący warunek:

$$
\forall x_1, x_2 \in X, \, \forall y_1, y_2 \in Y \, \left( (x_1, y_1) \in f \land (x_2, y_2) \in f : (x_1 = x_2) \Rightarrow (y_1 = y_2) \right)
$$

Oznacza to, że jeśli dla tego samego $x_1$ mamy dwie pary $(x_1, y_1)$ i $(x_1, y_2)$, to $y_1$ musi być równe $y_2$. Innymi słowy, żaden element z $X$ nie może być powiązany z więcej niż jednym elementem z $Y$.

### Ważne punkty:
1. **Relacja** w teorii mnogości to po prostu zbiór par uporządkowanych $(x, y)$, gdzie $x$ pochodzi ze zbioru $X$, a $y$ ze zbioru $Y$.
2. **Funkcja** to relacja, która dodatkowo spełnia warunek, że dla każdego $x$ istnieje dokładnie jedna para $(x, y)$ w tej relacji.

Zatem funkcja $f \subseteq X \times Y$ jest relacją, która spełnia dodatkowy warunek, że dla każdego $x \in X$ istnieje dokładnie jedno $y \in Y$ takie, że $(x, y) \in f$.


### Przykłady

**Przykład 1**

$$
f=\{(\text{pies}, \text{dog}), (\text{kot}, \text{cat}), (\text{koń}, \text{horse})\}
$$

**Przykład 2**

$$
f=\{(1,2), (2,3), (3,4)\}
$$

Co oznacza, że $f(1)=2$, $f(2)=3$ i $f(3)=4$.

**Przykład 3**

$$
f=\{(1,1),(2,1/2),(3,1/3),...\}=\{(n,1/n): n \in \mathbb{N}\}
$$

gdzie $\mathbb{N}$ oznacza zbiór liczb naturalnych. Funkcja ta przyporządkowuje każdemu $n$ liczbę $1/n$.

Często skracamy zapis ciągów takich jak ten do postaci $f(n)=1/n$.

**Przykład 4**

Funkcja kwadratowa często zapisywana jako $f(x)=x^2$ to funkcja, która każdemu $x$ przyporządkowuje $x^2$. W naszej notacji zapisujemy to jako 

$$
f=\{(x,x^2): x \in \mathbb{R}\}
$$

**Przykład 5**

Wyznacznik macierzy to funkcja, która każdej macierzy przyporządkowuje liczbę. W naszej notacji zapisujemy to jako

$$
f=\{(M,det(M)): M \text{ jest macierzą kwadratową}\}
$$

**Przykład 6**

Sama macierz jest też funkcją, która każdej parze indeksów $(i,j)$ gdzie $i,j \in \{1,2,...,n\}$ przyporządkowuje element macierzy na pozycji $(i,j)$. W naszej notacji zapisujemy to jako

$$
M=\{((i,j),M_{ij}): i,j \in \{1,2,...,n\}\}
$$

dla wygody zapisujemy to jako tablicę dwuwymiarową:

$$
M=\begin{bmatrix}
M_{11} & M_{12} & \cdots & M_{1n} \\
M_{21} & M_{22} & \cdots & M_{2n} \\
\vdots & \vdots & \ddots & \vdots \\
M_{n1} & M_{n2} & \cdots & M_{nn}
\end{bmatrix}
$$

**Przykład 7**

Dodawanie macierzy to funkcja, która każdej parze macierzy przyporządkowuje macierz. W naszej notacji zapisujemy to jako

$$
f=\{((A,B),A+B): A,B \text{ są macierzami o takich samych wymiarach}\}
$$

gdzie $A+B$ to macierz, której elementy są sumą elementów macierzy $A$ i $B$, czyli dla każdego $i,j$ mamy 
$$
(A+B)_{ij}=A_{ij}+B_{ij}
$$




**Przykład 8**

Słownik w pythonie to też funkcja, która każdemu kluczowi przyporządkowuje wartość. W naszej notacji zapisujemy to jako:

```{python}
f={1:1,2:4,3:9,4:16,5:25}
f
```

```{python}
# Odpytujemy słownik o wartości dla kluczy 1, 2, 3 podobnie jak zapisujemy to w matematyce!!!
print(f"Wartość dla klucza 1: f[1] = {f[1]}")
print(f"Wartość dla klucza 2: f[2] = {f[2]}")
print(f"Wartość dla klucza 3: f[3] = {f[3]}")
```

```{python}
# Przyklad kodowania kolorów w postaci słownika
color_codes = {"red": "#FF0000", "green": "#00FF00", "blue": "#0000FF"}
print(f"Kod koloru czerwonego: {color_codes['red']}")
print(f"Kod koloru zielonego: {color_codes['green']}")
print(f"Kod koloru niebieskiego: {color_codes['blue']}")
```

**Przyklad 9**

Sposób na zapisanie funkcji w pythonie jesy bardzo naturalny. 
Potrzebujemy:

* nadać jej nazwę
* zdefiniować argumenty
* określić operacje, które ma wykonać
* zwrócić wynik
    
    ```python
    def nazwa_funckji(argumenty):
        "coś robimy z argumentami"
        return wynik
    ```

```{python}
# Funkcja kwadratowa

def f(x):
    return x**2

# równoważnie jako lambda

f = lambda x: x**2

# Odpytujemy funkcję o wartości dla argumentów 1, 2, 3 podobnie jak zapisujemy to w matematyce!!!
print(f"Wartość dla argumentu 1: f(1) = {f(1)}")
print(f"Wartość dla argumentu 2: f(2) = {f(2)}")
print(f"Wartość dla argumentu 3: f(3) = {f(3)}")
```

```{python}
# Pochodna -  więcej na kolejnych zajęciach
import sympy as sp  # potrzebujemy biblioteki sympy
from IPython.display import display, Math  # do wyświetlania wyników jako LaTeX

x = sp.symbols('x')  # definiujemy zmienną x

def policz_pochodna(f):
    return sp.diff(f, x)

# definiujemy kilka funkcji do policzenia pochodnej
lista_funkcji = [x**2, sp.sin(x**3), sp.exp(sp.sin(x)), sp.log(x**2 + 1)]

# policzmy pochodne dla każdej z funkcji z listy
for f in lista_funkcji:
    # Wyświetlamy wynik jako LaTeX
    display(Math(r'Pochodna\ funkcji\ {}\ jest\ równa\ {}'.format(sp.latex(f), sp.latex(policz_pochodna(f)))))
```

```{python}
# Inne przykłady zapisu funkcji w sympy
f=(x+1)**2
g=sp.sin(x)
```

```{python}
# Możemy wyświetlić funkcje
f
```

```{python}
# Możemy dodać funkcje
f+g
```

```{python}
# Możemy różniczkować funkcje
f.diff(x)
```

```{python}
# Możemy całkować funkcje
f.integrate(x)
```

```{python}
# możemy rysoać funkcje
sp.plot(g, (x, -5, 5))
```

```{python}
# Możemy też definiować ogólne funkcje
f, g = sp.symbols('f g', cls=sp.Function)
f(x)+g(x)
```

```{python}
# możemy zobaczyć jedną z reguł całkowania
sp.expand(sp.integrate(f(x)+g(x), x))
```

